Q1. Which of these standard collection classes implements a dynamic array?
Options: 
a. AbstractList
b. AbstractSet
c. Arraylist
d. ArrayList

Answer = d. ArrayList

------------------------------------------------------------------------------------------------------------------
Q2. Which of these method of ArrayList class is used to obtain present size of an ArrayList object?
Options:
a. length()
b. size()
c. capacity()
d. index()

Answer = b. size()
-------------------------------------------------------------------------------------------------------------------
Q3. Which of the following declarations would be correct for a list that will contain Integers?
Options:
a. ArrayList<String> list = new ArrayList<String>() ;
b. ArrayList<int> list = new ArrayList<int>() ;
c. ArrayList list = new ArrayList() ;
d. ArrayList<Integer> list = new ArrayList<Integer>() ;

Answer = d. ArrayList<Integer> list = new ArrayList<Integer>() ;

-------------------------------------------------------------------------------------------------------------------

Q4. ArrayList<String> list = new ArrayList<String>() ;
list.add( "apple" );
list.add( "banana" );
list.add( "carrot" );
list.add( 0, "mango" );
What element will be at index 2 of the list?

Answer = banana

--------------------------------------------------------------------------------------------------------------------

Q5. ArrayList<String> list = new ArrayList<String>() ;
list.add( "Ant" );
list.add( "Bat" );
list.add( "Car" );
list.add( "Door" );
list.add( "Euro" );
Which of the following statements will replace the element "Car" with "Bus" ?
Options:
a. list[2] = "Bus" ;
b. list.add( "Bus", list.indexOf("Car") );
c. list.set( 2, "Bus" );
d. list.set( "Bus", "Car" );

Answer = c. list.set( 2, "Bus" );

----------------------------------------------------------------------------------------------------------------------

Q6. Linked List are best suited:
Options:
a. for relatively permanent collections of data.
b. for the size of the structure is constantly changing.
c. for random Access of elements
d. None of these

Answer = b. for the size of the structure is constantly changing.

-----------------------------------------------------------------------------------------------------------------------

Q7. What is Output?
Consider the Node class as shown below :
public class Node<T> {
  T data;
  Node<T> next;
  Node(T data){
    this.data = data;
  }
}
Now consider following code using Node class shown above.
public  class LinkedListUse{

 public static void print(Node<Integer> head){
    Node<Integer> temp = head;

    while(temp != null){
        System.out.print(temp.data +" ");
        temp = temp.next;
    }
    System.out.println();
}

public static void main(String args[]){

    Node<Integer> node1 = new Node<Integer>(10);
    Node<Integer> node2 = new Node<Integer>(20);
    node2.next = node1;
    print(node2);
   }
}
What will be the Output ?

Options:
a. 10 20
b. 20 10
c. Error
d. None of these

Answer = b. 20 10

--------------------------------------------------------------------------------------------------------------------------------

Q8. Predict The Output?
Consider the Node class as shown below :
public class Node<T> {
  T data;
  Node<T> next;
  Node(T data){
    this.data = data;
  }
}
Now consider following code using Node class shown above.
public  class LinkedListUse{

 public static void print(Node<Integer> head){
    Node<Integer> temp = head;

    while(temp != null){
        System.out.print(temp.data +" ");
        temp = temp.next;
    }
    System.out.println();
}

public static void main(String args[]){

    Node<Integer> node1 = new Node<Integer>(10);
    Node<Integer> node2 = new Node<Integer>(20);
    Node<Integer> node3 = new Node<Integer>(30);
    Node<Integer> node4 = new Node<Integer>(40);
    node1.next = node2;
    node2.next = node3;
    node3.next = node4;
    print(node2);
   }
}
What will be the Output ?

Options : 
a. 10 20 30 40
b. 20 30 40
c. 30 40
d. 10 30 40

Answer = b. 20 30 40

---------------------------------------------------------------------------------------------------------------------------

Q9. Find Output?
Consider the Node class as shown below :
public class Node<T> {
  T data;
  Node<T> next;
  Node(T data){
    this.data = data;
  }
}
Now consider following code using Node class shown above.
public  class LinkedListUse{

 public static void print(Node<Integer> head){
    Node<Integer> temp = head;

    while(temp != null){
        System.out.print(temp.data +" ");
        temp = temp.next;
    }
    System.out.println();
}

public static void increment(Node<Integer> head){
    Node<Integer> temp = head;
    while(temp != null){
        temp.data++;
        temp = temp.next;
    }
}

public static void main(String args[]){

    Node<Integer> node1 = new Node<Integer>(10);
    Node<Integer> node2 = new Node<Integer>(20);
    node1.next = node2;
    increment(node1);
    print(node1);
   }
}
What will be the Output ?

Options : 
a. 10 20
b. 11 21
c. Error
d. None of these

Answer = b. 11 21

----------------------------------------------------------------------------------------------------------------------------------
Q10. What will be the time complexity of searching an element in the linked list ?
Options: 
a. O(1)
b. O(n)
c. O(nlogn)
d. O(n^2)

Answer = b. O(n)

------------------------------------------------------------------------------------------------------------------------------

Q11. Consider the Singly linked list having n elements. What will be the time taken to add an node at the end of linked list if is initially pointing to first node of the list.
That is only head is given to you.
Options: 
a. O(n)
b. O(1)
c. O(nlogn)
d. O(n^2)

Answer = a. O(n)

----------------------------------------------------------------------------------------------------------------------------------
Q12. There is reference (or pointer) to first Node of the Linked List, then time required to insert element to second position is __________.
Indexing starts from 0.
Options:
a. O(1)
b. O(n)
c. O(nlogn)
d. O(n^2)

Answer = a. O(1)

---------------------------------------------------------------------------------------------------------------------------------------

Q13. Given an unsorted singly Linked List, suppose you have reference (or pointer) to its head node only, which of the following operation can be implemented in O(1) time?
i)   Insertion at the front of the linked list
ii)  Insertion at the end of the linked list
iii) Deletion of the last node of the linked list
iv)  Deletion of the front node of the linked list

Answer = I and IV

-----------------------------------------------------------------------------------------------------------------------------------------

Q14. Given an unsorted singly Linked List, suppose you have references (or pointer) to its head and tail nodes, which of the following operation can be implemented in O(1) time?
i)   Insertion at the front of the linked list
ii)  Insertion at the end of the linked list
iii) Deletion of the last node of the linked list
iv)  Deletion of the front node of the linked list

Answer =  I,II and IV

-----------------------------------------------------------------------------------------------------------------------------------------
